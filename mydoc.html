<!DOCTYPE html>
<html>
<head>
<title>First Look !</title>
<link href="main.css" rel="stylesheet" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<script>const headNum = {"sectionNon-crossing matchings and bounds using conjugacy invariance": "4", "sectionConcluding remarks": "5", "sectionIntroduction": "1", "sectionDomain Specific Foundations using Type theory": "3", "sectionHomogeneous length functions and the Internal repetition trick": "2"};</script>
<script>const labelNum = {"S:noncross": "4", "S:Conclusions": "5", "L:Bound": "Listing 1", "main": "2.9", "abab": "3", "S:DSF": "3", "S:Homogeneous": "2"};</script>
<script>const thmNum = {"ConjectureFor any homogeneous, on , we have , where .": "2.6", "DefinitionA pseudo-length func on a group  is said to be a  if  for all .": "2.4", "DefinitionA pseudo-length func on a group  is said to be  if  for all .": "2.2", "DefinitionThe type family  is the indexed indu": "3.1", "DefinitionA  on a group  is a function  such that	": "2.1", "LemmaLet . Then ": "2.8", "DefinitionA pseudo-length func on a group  is said to be  if  for all , .": "2.3", "LemmaLet , , ,  in  be such that  is conjugateto bot and . Then one has": "2.7", "TheoremFor every homogeneou, we have . In particular  is not a length fun": "2.9", "QuestionIs there a homogeneo on the free group  on  generators?": "2.5"};</script>
<script>const eqNum = {};</script>
<script>const codeNum = {"// class whose objec": "Listing 1"};</script>
<script>const figNum = {};</script>
<script>const tableNum = {};</script>
</head>
<body style="margin: 0px;">
<div id="topmatter">
<a href="#topmatter">
<table>
<tr>
<td style="width: 25%;">Siddhartha Gadgil</td>
<td style="width: 50%;">Homogeneous length functions on Groups: 
Intertwined computer &amp; human proofs</td>
<td style="width: 25%;">\today</td>
</tr>
</table>
</a>
<div id="abstract">
<h3>Abstract</h3>
<p class="paragraph">
<span class="text">
We describe  a case of an interplay between human and computer proving which played a role in the discovery of an interesting mathematical result</span>
<span class="citation">
<sup>
<strong>polymath</strong>
</sup>
</span>
<span class="text">. The unusual feature of the use of computers here was that a computer generated but human readable proof was read, understood, generalized and abstracted by mathematicians to obtain the key lemma in a significant mathematical result.
</span>
</p>
</div>
</div>
<div id="mainbody">
<div class="body">
<div class="command">
<h3>subjclass: 03B15 (primary), 20F12, 20F65 (secondary)</h3>
</div>
<p class="paragraph">
<span class="text">

</span>
</p>
<div class="heading">
<span class="section">
<span id="sectionIntroduction">
<script>document.getElementById("sectionIntroduction").innerHTML = headNum["sectionIntroduction"];</script>
</span>Introduction</span>
</div>
<p class="paragraph">
<span class="text">Computers have come to play many roles in mathematical proofs. Computer experimentation is commonly used to make conjectures and computer algebra systems are used for sophisticated calculations. Components of proofs of import results have also been provided by computers. Such rigorous computer proofs often generate independently verifiable </span>
<em>
<span class="text">proof certificates</span>
</em>
<span class="text">. Proof assistants have been used to formalize proofs, including some very complex ones.

Here we describe a case different from these -- where a computer generated but </span>
<span class="hyperlink">
<a href="https://github.com/siddhartha-gadgil/Superficial/wiki/A-commutator-bound">human readable</a>
</span>
<span class="text"> proof  was read, understood, generalized and abstracted by mathematicians to obtain the key lemma in a significant mathematical result. So far as we know this is the only such instance so far.

The result whose discovery involved a computer-generated proof concerned the existence of so called </span>
<em>
<span class="text">homogeneous length functions</span>
</em>
<span class="text"> </span>
<span class="inlinemath">\(l: \langle \alpha, \beta \rangle \to \mathbb{R}\)</span>
<span class="text"> on the free groups on two generators (we give precise statements in Section</span>
<span class="reference">
<a id="refS:Homogeneous" href="#S:Homogeneous">
<script>document.getElementById("refS:Homogeneous").innerHTML = labelNum["S:Homogeneous"];</script>
</a>
</span>
<span class="text">). This was asked by Terrence Tao on his blog (Apoorva Khare had asked Tao this question) and was answered  in six days in a collaboration that became PolyMath14</span>
<span class="notemark">
<a href="#footer">
<sup>[?]</sup>
</a>
</span>
<span class="text">.

Our computer generated proof of a bound on </span>
<span class="inlinemath">\(l([\alpha, \beta])\)</span>
<span class="text"> for homogeneous length functions </span>
<span class="inlinemath">\(l\)</span>
<span class="text"> played a role in the discovery of the proof of the main result. The computer proof was posted in a human readable form -- this was studied, generalized and abstracted to prove the key lemma.

We feel that such proofs intertwining human and computer proving are significant. Mathematical proofs not only establish the truth of statements but also form the basis of further mathematical development. Indeed, a (human) proof of a significant mathematical result inevitably results in further mathematical discoveries. However computer generated proofs, even of important mathematical results, are generally not very useful in this way.

Underlying the computer generated, human readable proofs were </span>
<em>
<span class="text">type theory</span>
</em>
<span class="text"> based </span>
<em>
<span class="text">domain specific foundations</span>
</em>
<span class="text">. Namely, we defined a </span>
<em>
<span class="text">class</span>
</em>
<span class="text"> whose </span>
<em>
<span class="text">objects</span>
</em>
<span class="text"> were proofs of statements of a specific nature. Here the terms class and object can be understood both in the sense of the words in common English usage and in the sense of object-oriented programming. We also implemented algorithms to generate such proof objects. Further, it was straightforward to transform a proof object to a human readable form.

Conceptually our approach was based on the type theory underlying </span>
<em>
<span class="text">homotopy type theory</span>
</em>
<span class="citation">
<sup>
<strong>hott</strong>
</sup>
</span>
<span class="text">, with statements represented by types belonging to an indexed inductive type family, and proofs terms having these types.  We see more details of the type theory and the </span>
<em>
<span class="text">scala</span>
</em>
<span class="text"> implementation in Section</span>
<span class="reference">
<a id="refS:DSF" href="#S:DSF">
<script>document.getElementById("refS:DSF").innerHTML = labelNum["S:DSF"];</script>
</a>
</span>
<span class="text">. We discuss the algorithms used to find (proofs of) bounds in Section</span>
<span class="reference">
<a id="refS:noncross" href="#S:noncross">
<script>document.getElementById("refS:noncross").innerHTML = labelNum["S:noncross"];</script>
</a>
</span>
<span class="text">. Finally we discuss the role of foundations and limitations and extensions of our approach in Section</span>
<span class="reference">
<a id="refS:Conclusions" href="#S:Conclusions">
<script>document.getElementById("refS:Conclusions").innerHTML = labelNum["S:Conclusions"];</script>
</a>
</span>
<span class="text">.

This note is intended to be complementary to</span>
<span class="citation">
<sup>
<strong>polymath</strong>
</sup>
</span>
<span class="text">, to which we refer for proofs, motivation for the questions, and other details of the mathematics.

</span>
</p>
<div class="heading">
<span class="section">
<span id="sectionHomogeneous_length_functions_and_the_Internal_repetition_trick">
<script>document.getElementById("sectionHomogeneous_length_functions_and_the_Internal_repetition_trick").innerHTML = headNum["sectionHomogeneous length functions and the Internal repetition trick"];</script>
</span>
<a name="S:Homogeneous">
</a>Homogeneous length functions and the Internal repetition trick</span>
</div>
<p class="paragraph">
<span class="text">To state the main question, we need some definitions.
</span>
</p>
<div class="theorem">
<div class="name">Definition<span id="DefinitionA__on_a_group__is_a_function__such_that	">
<script>document.getElementById("DefinitionA__on_a_group__is_a_function__such_that	").innerHTML = thmNum["DefinitionA  on a group  is a function  such that	"];</script>
</span>
</div>
<div class="body">
<p class="paragraph">
<span class="text">A </span>
<em>
<span class="text">pseudo-length function</span>
</em>
<span class="text"> on a group </span>
<span class="inlinemath">\(G\)</span>
<span class="text"> is a function </span>
<span class="inlinemath">\(l: G \to [0, \infty)\)</span>
<span class="text"> such that
	</span>
</p>
<ul>
<li class="item">
<div class="body">
<p class="paragraph">
<span class="inlinemath">\(l(e) = 0\)</span>
<span class="text">.
		</span>
</p>
</div>
</li>
<li class="item">
<div class="body">
<p class="paragraph">
<span class="inlinemath">\(l(g^{-1}) = l(g)\)</span>
<span class="text"> for all </span>
<span class="inlinemath">\(g \in G\)</span>
<span class="text">.
		</span>
</p>
</div>
</li>
<li class="item">
<div class="body">
<p class="paragraph">
<span class="inlinemath">\(l(gh) \leq l(g) + l(h)\)</span>
<span class="text"> for all </span>
<span class="inlinemath">\(g,h\in G\)</span>
<span class="text">.
	</span>
</p>
</div>
</li>
</ul>
</div>
</div>
<div class="theorem">
<div class="name">Definition<span id="DefinitionA_pseudo-length_func_on_a_group__is_said_to_be__if__for_all_.">
<script>document.getElementById("DefinitionA_pseudo-length_func_on_a_group__is_said_to_be__if__for_all_.").innerHTML = thmNum["DefinitionA pseudo-length func on a group  is said to be  if  for all ."];</script>
</span>		[Conjugacy invariance]</div>
<div class="body">
<p class="paragraph">
<span class="text">A pseudo-length function </span>
<span class="inlinemath">\(l\)</span>
<span class="text"> on a group </span>
<span class="inlinemath">\(G\)</span>
<span class="text"> is said to be </span>
<em>
<span class="text">conjugacy invariant</span>
</em>
<span class="text"> if </span>
<span class="inlinemath">\(l(ghg^{-1}) = l(h)\)</span>
<span class="text"> for all </span>
<span class="inlinemath">\(g, h\in G\)</span>
<span class="text">.
</span>
</p>
</div>
</div>
<div class="theorem">
<div class="name">Definition<span id="DefinitionA_pseudo-length_func_on_a_group__is_said_to_be__if__for_all_,_.">
<script>document.getElementById("DefinitionA_pseudo-length_func_on_a_group__is_said_to_be__if__for_all_,_.").innerHTML = thmNum["DefinitionA pseudo-length func on a group  is said to be  if  for all , ."];</script>
</span>		[Homogeneity]</div>
<div class="body">
<p class="paragraph">
<span class="text">A pseudo-length function </span>
<span class="inlinemath">\(l\)</span>
<span class="text"> on a group </span>
<span class="inlinemath">\(G\)</span>
<span class="text"> is said to be </span>
<em>
<span class="text">homogeneous</span>
</em>
<span class="text"> if </span>
<span class="inlinemath">\(l(g^n) = nl(g)\)</span>
<span class="text"> for all </span>
<span class="inlinemath">\(g\in G\)</span>
<span class="text">, </span>
<span class="inlinemath">\(n \in\mathbb{Z}\)</span>
<span class="text">.
</span>
</p>
</div>
</div>
<div class="theorem">
<div class="name">Definition<span id="DefinitionA_pseudo-length_func_on_a_group__is_said_to_be_a__if__for_all_.">
<script>document.getElementById("DefinitionA_pseudo-length_func_on_a_group__is_said_to_be_a__if__for_all_.").innerHTML = thmNum["DefinitionA pseudo-length func on a group  is said to be a  if  for all ."];</script>
</span>		[Positivity]</div>
<div class="body">
<p class="paragraph">
<span class="text">A pseudo-length function </span>
<span class="inlinemath">\(l\)</span>
<span class="text"> on a group </span>
<span class="inlinemath">\(G\)</span>
<span class="text"> is said to be a </span>
<em>
<span class="text">length function</span>
</em>
<span class="text"> if </span>
<span class="inlinemath">\(l(g) &gt; 0\)</span>
<span class="text"> for all </span>
<span class="inlinemath">\(g\in G \setminus \{ e \}\)</span>
<span class="text">.
</span>
</p>
</div>
</div>
<p class="paragraph">
<span class="text">Recall that the free group </span>
<span class="inlinemath">\(\langle \alpha, \beta \rangle\)</span>
<span class="text"> on </span>
<span class="inlinemath">\(2\)</span>
<span class="text"> generators </span>
<span class="inlinemath">\(\alpha\)</span>
<span class="text"> and </span>
<span class="inlinemath">\(\beta\)</span>
<span class="text"> is the group whose elements are words in </span>
<span class="inlinemath">\(\alpha\)</span>
<span class="text">, </span>
<span class="inlinemath">\(\beta\)</span>
<span class="text">, </span>
<span class="inlinemath">\(\alpha^{-1}\)</span>
<span class="text"> and </span>
<span class="inlinemath">\(\beta^{-1}\)</span>
<span class="text">, with the only relations being cancellation of pairs of adjacent letter of the form </span>
<span class="inlinemath">\(\alpha\)</span>
<span class="text"> and </span>
<span class="inlinemath">\(\alpha^{-1}\)</span>
<span class="text"> or </span>
<span class="inlinemath">\(\beta\)</span>
<span class="text"> and </span>
<span class="inlinemath">\(\beta^{-1}\)</span>
<span class="text"> (for example, </span>
<span class="inlinemath">\(\alpha\beta\beta^{-1}\alpha\beta\alpha^{-1} = \alpha\alpha\beta\alpha^{-1}\neq\alpha\beta\)</span>
<span class="text">).
Terrence Tao posted on his blog the following question, asked to him by Apporva Khare.

</span>
</p>
<div class="theorem">
<div class="name">Question<span id="QuestionIs_there_a_homogeneo_on_the_free_group__on__generators?">
<script>document.getElementById("QuestionIs_there_a_homogeneo_on_the_free_group__on__generators?").innerHTML = thmNum["QuestionIs there a homogeneo on the free group  on  generators?"];</script>
</span>
</div>
<div class="body">
<p class="paragraph">
<span class="text">Is there a homogeneous, conjugacy-invariant length function </span>
<span class="inlinemath">\(l\)</span>
<span class="text"> on the free group </span>
<span class="inlinemath">\(\langle \alpha, \beta \rangle\)</span>
<span class="text"> on </span>
<span class="inlinemath">\(2\)</span>
<span class="text"> generators?
</span>
</p>
</div>
</div>
<p class="paragraph">
<span class="text">It is natural to view this as asking whether a homogeneous, conjugacy-invariant pseudo-length function </span>
<span class="inlinemath">\(l\)</span>
<span class="text"> on </span>
<span class="inlinemath">\(G\)</span>
<span class="text"> can also be positive, hence a length functions. Further, we can normalize to assume that </span>
<span class="inlinemath">\(l(s)\leq 1\)</span>
<span class="text"> for </span>
<span class="inlinemath">\(s=\alpha, \beta\)</span>
<span class="text"> (hence, by symmetry, also for </span>
<span class="inlinemath">\(s = \alpha^{-1}, \beta^{-1}\)</span>
<span class="text">). We shall say </span>
<span class="inlinemath">\(l\)</span>
<span class="text"> is </span>
<em>
<span class="text">normalized</span>
</em>
<span class="text"> if </span>
<span class="inlinemath">\(l(s)\leq 1\)</span>
<span class="text"> for </span>
<span class="inlinemath">\(s=\alpha, \beta, \alpha^{-1}, \beta^{-1}\)</span>
<span class="text">.

After the failure of various constructions (by day </span>
<span class="inlinemath">\(3\)</span>
<span class="text">), the following conjecture seemed likely.

</span>
</p>
<div class="theorem">
<div class="name">Conjecture<span id="ConjectureFor_any_homogeneous,_on_,_we_have_,_where_.">
<script>document.getElementById("ConjectureFor_any_homogeneous,_on_,_we_have_,_where_.").innerHTML = thmNum["ConjectureFor any homogeneous, on , we have , where ."];</script>
</span>
</div>
<div class="body">
<p class="paragraph">
<span class="text">For any homogeneous, conjugacy-invariant pseudo-length function </span>
<span class="inlinemath">\(l\)</span>
<span class="text"> on </span>
<span class="inlinemath">\(\langle \alpha, \beta \rangle\)</span>
<span class="text">, we have </span>
<span class="inlinemath">\(l([\alpha, \beta]) = 0\)</span>
<span class="text">, where </span>
<span class="inlinemath">\([\alpha, \beta] = \alpha\beta\alpha^{-1}\beta^{-1}\)</span>
<span class="text">.
</span>
</p>
</div>
</div>
<p class="paragraph">
<span class="text">In particular, this conjecture implies that </span>
<span class="inlinemath">\(l\)</span>
<span class="text"> cannot be a length function.

Several bounds were obtained on </span>
<span class="inlinemath">\(l([\alpha, \beta])\)</span>
<span class="text"> from the hypothesis, giving bounds that even went below </span>
<span class="inlinemath">\(1\)</span>
<span class="text">. However, these methods appeared to stagnate with the best bound above </span>
<span class="inlinemath">\(0.9\)</span>
<span class="text">.

Using computer-assistance, we obtained and posted
 a </span>
<span class="hyperlink">
<a href="https://github.com/siddhartha-gadgil/Superficial/wiki/A-commutator-bound">human readable</a>
</span>
<span class="text"> proof showing </span>
<span class="inlinemath">\(l([\alpha, \beta]) \leq 0.82\)</span>
<span class="text">.
 An extract of this proof is as follows</span>
<span class="notemark">
<a href="#footer">
<sup>[?]</sup>
</a>
</span>
<span class="text">. Note that we have used somewhat different notation here -- the generators are </span>
<span class="inlinemath">\(a\)</span>
<span class="text"> and </span>
<span class="inlinemath">\(b\)</span>
<span class="text"> and their inverses are denoted </span>
<span class="inlinemath">\(\bar{a}\)</span>
<span class="text"> and </span>
<span class="inlinemath">\(\bar{b}\)</span>
<span class="text">. We remark that a fully expanded proof actually had over 2000 lines, but avoiding duplication gave the posted </span>
<span class="inlinemath">\(126\)</span>
<span class="text"> lines.

</span>
</p>
<div class="environment">
<div class="name">None</div>
<div class="envbody">
<div class="body">
<p class="paragraph">
</p>
<ul>
<li class="item">
<div class="body">
<p class="paragraph">
<span class="inlinemath">\(|\bar{a}| \leq 1.0\)</span>
<span class="text">
	</span>
</p>
</div>
</li>
<li class="item">
<div class="body">
<p class="paragraph">
<span class="inlinemath">\(|\bar{b}\bar{a}b| \leq 1.0\)</span>
<span class="text"> using </span>
<span class="inlinemath">\(|\bar{a}| \leq 1.0\)</span>
<span class="text">
	</span>
</p>
</div>
</li>
<li class="item">
<div class="body">
<p class="paragraph">
<span class="inlinemath">\(|\bar{b}| \leq 1.0\)</span>
<span class="text">
	</span>
</p>
</div>
</li>
<li class="item">
<div class="body">
<p class="paragraph">
<span class="inlinemath">\(|a\bar{b}\bar{a}| \leq 1.0\)</span>
<span class="text"> using </span>
<span class="inlinemath">\(|\bar{b}| \leq 1.0\)</span>
<span class="text">
	</span>
</p>
</div>
</li>
<li class="item">
<div class="body">
<p class="paragraph">
<span class="inlinemath">\(|\bar{a}\bar{b}ab\bar{a}\bar{b}| \leq 2.0\)</span>
<span class="text"> using </span>
<span class="inlinemath">\(|\bar{a}\bar{b}a| \leq 1.0\)</span>
<span class="text"> and </span>
<span class="inlinemath">\(|b\bar{a}\bar{b}| \leq 1.0\)</span>
<span class="text">
	</span>
</p>
</div>
</li>
<li class="item">
<div class="body">
<p class="paragraph">
<span class="text">... (119 lines)
	</span>
</p>
</div>
</li>
<li class="item">
<div class="body">
<p class="paragraph">
<span class="inlinemath">\(|ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}| \leq 13.859649122807017\)</span>
<span class="text"> 
using </span>
<span class="inlinemath">\(|ab\bar{a}| \leq 1.0\)</span>
<span class="text"> and 
</span>
<span class="inlinemath">\(|\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}| \leq 12.859649122807017\)</span>
<span class="text">
	</span>
</p>
</div>
</li>
<li class="item">
<div class="body">
<p class="paragraph">
<span class="inlinemath">\(|ab\bar{a}\bar{b}| \leq 0.8152734778121775\)</span>
<span class="text"> using 
</span>
<span class="inlinemath">\(|ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}ab\bar{a}\bar{b}| \leq 13.859649122807017\)</span>
<span class="text"> by 
taking 17th power.
</span>
</p>
</div>
</li>
</ul>
</div>
</div>
</div>
<p class="paragraph">
<span class="text">This proof was studied, understood and generalized by Pace Nielsen, who called the method the </span>
<em>
<span class="text">internal repetition trick</span>
</em>
<span class="text">. After several improvements due to Nielsen and Tobias Fritz, this was abstraced by Terrence Tao as the following lemma.
</span>
</p>
<div class="theorem">
<div class="name">Lemma<span id="LemmaLet_,_,_,__in__be_such_that__is_conjugateto_bot_and_._Then_one_has">
<script>document.getElementById("LemmaLet_,_,_,__in__be_such_that__is_conjugateto_bot_and_._Then_one_has").innerHTML = thmNum["LemmaLet , , ,  in  be such that  is conjugateto bot and . Then one has"];</script>
</span>
</div>
<div class="body">
<p class="paragraph">
<span class="text">Let </span>
<span class="inlinemath">\(x\)</span>
<span class="text">, </span>
<span class="inlinemath">\(y\)</span>
<span class="text">, </span>
<span class="inlinemath">\(z\)</span>
<span class="text">, </span>
<span class="inlinemath">\(w\)</span>
<span class="text"> in </span>
<span class="inlinemath">\(G\)</span>
<span class="text"> be such that </span>
<span class="inlinemath">\(x\)</span>
<span class="text"> is conjugate
to both </span>
<span class="inlinemath">\(wy\)</span>
<span class="text"> and </span>
<span class="inlinemath">\(zw^{-1}\)</span>
<span class="text">. Then one has
</span>
</p>
<div class="displaymath">
<div id="l(x)\leq\frac{l(y)_+">
<script>document.getElementById("l(x)\leq\frac{l(y)_+").innerHTML = eqNum["l(x)\leq\frac{l(y) +"];</script>
</div>\[l(x)\leq\frac{l(y) + l(z)}{2}.\]</div>
</div>
</div>
<p class="paragraph">
<span class="text">Fritz used this to obtain the key lemma.

</span>
</p>
<div class="theorem">
<div class="name">Lemma<span id="LemmaLet_._Then">
<script>document.getElementById("LemmaLet_._Then").innerHTML = thmNum["LemmaLet . Then "];</script>
</span>
</div>
<div class="body">
<p class="paragraph">
<span class="text">Let </span>
<span class="inlinemath">\(f(m,k)=l(x^m [x,y]^k)\)</span>
<span class="text">. Then </span>
</p>
<div class="displaymath">
<div id="f(m,k)\leq_\frac{f(m">
<script>document.getElementById("f(m,k)\leq_\frac{f(m").innerHTML = eqNum["f(m,k)\leq \frac{f(m"];</script>
</div>\[f(m,k)\leq \frac{f(m-1,k)+f(m+1,k-1)}{2}.\]</div>
</div>
</div>
<p class="paragraph">
<span class="text">A probabilistic argument using this, due to Tao, showed that </span>
<span class="inlinemath">\(l([\alpha, \beta])=0\)</span>
<span class="text">. This answered the question (the main result proved in</span>
<span class="citation">
<sup>
<strong>polymath</strong>
</sup>
</span>
<span class="text"> is actually stronger than the statement of</span>
<span class="reference">
<a id="refmain" href="#main">
<script>document.getElementById("refmain").innerHTML = labelNum["main"];</script>
</a>
</span>
<span class="text">).
</span>
</p>
<div class="theorem">
<div class="name">
<a name="main">
</a>Theorem<span id="TheoremFor_every_homogeneou,_we_have_._In_particular__is_not_a_length_fun">
<script>document.getElementById("TheoremFor_every_homogeneou,_we_have_._In_particular__is_not_a_length_fun").innerHTML = thmNum["TheoremFor every homogeneou, we have . In particular  is not a length fun"];</script>
</span>		[see ~\cite{polymath}]</div>
<div class="body">
<p class="paragraph">
<span class="text">For every homogeneous, conjugacy-invariant pseudo-length function </span>
<span class="inlinemath">\(l:\langle \alpha, \beta \rangle\to [0, \infty)\)</span>
<span class="text">, we have </span>
<span class="inlinemath">\(l([\alpha, \beta]) =0\)</span>
<span class="text">. In particular </span>
<span class="inlinemath">\(l\)</span>
<span class="text"> is not a length function.
</span>
</p>
</div>
</div>
<div class="heading">
<span class="section">
<span id="sectionDomain_Specific_Foundations_using_Type_theory">
<script>document.getElementById("sectionDomain_Specific_Foundations_using_Type_theory").innerHTML = headNum["sectionDomain Specific Foundations using Type theory"];</script>
</span>
<a name="S:DSF">
</a>Domain Specific Foundations using Type theory</span>
</div>
<p class="paragraph">
<span class="text">We now turn to the type-theoretic formulations. For background we refer to</span>
<span class="citation">
<sup>
<strong>hott</strong>
</sup>
</span>
<span class="text">.

For an element </span>
<span class="inlinemath">\(g\in\langle \alpha, \beta \rangle\)</span>
<span class="text"> and a real number </span>
<span class="inlinemath">\(a\in \mathbb{R}\)</span>
<span class="text">, let </span>
<span class="inlinemath">\(\mathcal{B}(g)(a)\)</span>
<span class="text"> be the proposition (i.e., logical statement) that </span>
<span class="inlinemath">\(l(g)\leq a\)</span>
<span class="text"> for all homogeneous, conjugacy-invariant pseudo-lengths on </span>
<span class="inlinemath">\(\langle \alpha, \beta \rangle\)</span>
<span class="text"> with </span>
<span class="inlinemath">\(l(\alpha),l(\beta)\leq 1\)</span>
<span class="text">. Recall that we can (and do) regard this as a type under the Curry-Howard correspondence.

Let </span>
<span class="inlinemath">\(S\)</span>
<span class="text"> be the type given by </span>
<span class="inlinemath">\(S=\{\alpha, \beta, \alpha^{-1}, \beta^{-1}\}\)</span>
<span class="text">, i.e., the symmetrized set of generators. Let  </span>
<span class="inlinemath">\(\langle \alpha, \beta \rangle\)</span>
<span class="text"> and </span>
<span class="inlinemath">\(\mathbb{R}\)</span>
<span class="text">  be types corresponding to the free group and reals, respectively. For simplicity we abuse notation and regard elements of </span>
<span class="inlinemath">\(S\)</span>
<span class="text"> as elements of </span>
<span class="inlinemath">\(\langle \alpha, \beta \rangle\)</span>
<span class="text"> (instead of using an inclusion function).

We model bounds on </span>
<span class="inlinemath">\(l(g)\)</span>
<span class="text">, for </span>
<span class="inlinemath">\(l\)</span>
<span class="text"> as above and </span>
<span class="inlinemath">\(g\in\langle \alpha, \beta \rangle\)</span>
<span class="text">, as an indexed inductive type family </span>
<span class="inlinemath">\(\mathcal{B}: \prod_{g\in \langle \alpha, \beta \rangle}\prod_{a \in \mathbb{R}} \mathcal{U}\)</span>
<span class="text">. The assumptions on </span>
<span class="inlinemath">\(l\)</span>
<span class="text"> are essentially captured in the introduction rules. However, we do not explicitly assume symmetry, instead assuming bounds on lengths for generators as well as their inverses. Further, we only assume invariance under conjugacy by generators and their inverses (this immediately implies conjugacy invariance).

In the following definition, the term </span>
<span class="inlinemath">\(\mathfrak{g}\)</span>
<span class="text"> corresponds to the hypothesis that </span>
<span class="inlinemath">\(l(s)\leq 1\)</span>
<span class="text"> for </span>
<span class="inlinemath">\(s\in S\)</span>
<span class="text">.
 The terms </span>
<span class="inlinemath">\(\mathfrak{t}\)</span>
<span class="text">, </span>
<span class="inlinemath">\(\mathfrak{c}\)</span>
<span class="text">, </span>
<span class="inlinemath">\(\mathfrak{h}\)</span>
<span class="text">  correspond to  the triangle inequality, conjugacy invariance, and  homogeneity, respectively. The term </span>
<span class="inlinemath">\(\mathfrak{e}\)</span>
<span class="text"> corresponds to </span>
<span class="inlinemath">\(l(e) =0\)</span>
<span class="text">.
As we only relate bounds on all lengths satisying the hypothesis with other such bounds, and do not consider specific length functions, some of the statements (such as the triangle inequality) have a somewhat compicated form.

</span>
</p>
<div class="theorem">
<div class="name">Definition<span id="DefinitionThe_type_family__is_the_indexed_indu">
<script>document.getElementById("DefinitionThe_type_family__is_the_indexed_indu").innerHTML = thmNum["DefinitionThe type family  is the indexed indu"];</script>
</span>		[Types for bounds]</div>
<div class="body">
<p class="paragraph">
<span class="text">The type family </span>
<span class="inlinemath">\(\mathcal{B}: \prod_{g\in \langle \alpha, \beta \rangle}\prod_{a \in \mathbb{R}} \mathcal{U}\)</span>
<span class="text"> is the indexed inductive type family freely generated by
  </span>
</p>
<ul>
<li class="item">
<div class="body">
<p class="paragraph">
<span class="inlinemath">\(\mathfrak{g} : \prod_{s: S} \mathcal{B}(s)(1)\)</span>
<span class="text">
    </span>
</p>
</div>
</li>
<li class="item">
<div class="body">
<p class="paragraph">
<span class="inlinemath">\(\mathfrak{t}: \prod_{g: \langle \alpha, \beta \rangle}\prod_{h: \langle \alpha, \beta \rangle}\prod_{a: \mathbb{R}}\prod_{b : \mathbb{R}}\mathcal{B}(g)(a) \to \mathcal{B}(h)(b) \to \mathcal{B}(gh)(a + b)\)</span>
<span class="text">
    </span>
</p>
</div>
</li>
<li class="item">
<div class="body">
<p class="paragraph">
<span class="inlinemath">\(\mathfrak{c} : \prod_{s: S}\prod_{g: \langle \alpha, \beta \rangle}\prod_{a: \mathbb{R}}\mathcal{B}(g)(a) \to \mathcal{B}(sgs^{-1})(a)\)</span>
<span class="text">
    </span>
</p>
</div>
</li>
<li class="item">
<div class="body">
<p class="paragraph">
<span class="inlinemath">\(\mathfrak{h}: \prod_{g: \langle \alpha, \beta \rangle}\prod_{n: \mathbb{Z}}\prod_{a: \mathbb{R}}\mathcal{B}(g^n)(a) \to \mathcal{B}(g)(a/n)\)</span>
<span class="text">
    </span>
</p>
</div>
</li>
<li class="item">
<div class="body">
<p class="paragraph">
<span class="inlinemath">\(\mathfrak{e}: B(e)(0)\)</span>
<span class="text">
  </span>
</p>
</div>
</li>
</ul>
</div>
</div>
<p class="paragraph">
<span class="text">Note that any well-formed term </span>
<span class="inlinemath">\(p: B(g)(a)\)</span>
<span class="text"> is a correct proof of the bound </span>
<span class="inlinemath">\(l(g)\leq a\)</span>
<span class="text"> under the hypothesis that </span>
<span class="inlinemath">\(l\)</span>
<span class="text"> is a normalized, homogeneous, conjugacy-invariant pseudo-length on </span>
<span class="inlinemath">\(\langle \alpha, \beta \rangle\)</span>
<span class="text">. This is independent of the act of finding the proof. Further, a proof of this form  is not very different from a standard mathematical proof, and it is easy to see how this translates to a human readable form.

As an example, we write some proofs in this sense in a fully expanded form. The term</span>
<span class="reference">
<a id="refabab" href="#abab">
<script>document.getElementById("refabab").innerHTML = labelNum["abab"];</script>
</a>
</span>
<span class="text"> below is a proof that </span>
<span class="inlinemath">\(l([\alpha, \beta]) \leq 2\)</span>
<span class="text">.
</span>
</p>
<ol>
<li class="item">
<div class="body">
<p class="paragraph">
<span class="inlinemath">\(\mathfrak{g}(\beta) : \mathcal{B}(\beta)(1)\)</span>
<span class="text">
  </span>
</p>
</div>
</li>
<li class="item">
<div class="body">
<p class="paragraph">
<span class="inlinemath">\(\mathfrak{c}(\alpha)(\beta)(1)(\mathfrak{g}(\beta)) : \mathcal{B}(\alpha\beta\alpha^{-1})(1)\)</span>
<span class="text">
  </span>
</p>
</div>
</li>
<li class="item">
<div class="body">
<p class="paragraph">
<span class="inlinemath">\(\mathfrak{t}(\alpha\beta\alpha^{-1})(\beta^{-1})(1)(1)(\mathfrak{c}(\alpha)(\beta)(1)(\mathfrak{g}(\beta)))(\mathfrak{g}(\beta^{-1})) : \mathcal{B}(\alpha\beta\alpha^{-1}\beta^{-1})(2)\)</span>
<span class="text">
</span>
</p>
</div>
<a name="abab">
</a>
</li>
</ol>
<p class="paragraph">
<span class="text">The inductive definition essentially translates into the </span>
<em>
<span class="text">scala</span>
</em>
<span class="text"> code in Listing</span>
<span class="reference">
<a id="refL:Bound" href="#L:Bound">
<script>document.getElementById("refL:Bound").innerHTML = labelNum["L:Bound"];</script>
</a>
</span>
<span class="text">. The terminology </span>
<em>
<span class="text">LinNormBound</span>
</em>
<span class="text"> is that used in the blog discussions at that time, starting from the original question (the rest of this note uses the terminology of</span>
<span class="citation">
<sup>
<strong>polymath</strong>
</sup>
</span>
<span class="text">).

</span>
</p>
<div class="codeBlock">
<a name="L:Bound">
</a>
<pre>
<code>// class whose objects are bounds on lengths
sealed abstract class LinNormBound(val word: Word, val bound: Double)

// bound on lengths of generators
final case class Gen(n: Int) extends LinNormBound(Word(Vector(n)), 1)


// invariance under conjugacy by generators
final case class ConjGen(n: Int, pf: LinNormBound) extends
                          LinNormBound(n +: pf.word :+ (-n), pf.bound)

// the triangle inequality
final case class Triang(pf1: LinNormBound, pf2: LinNormBound) extends
            LinNormBound(pf1.word ++ pf2.word, pf1.bound + pf2.bound)

// homogeneity
final case class PowerBound(
  base: Word, n: Int, pf: LinNormBound) extends
                                    LinNormBound(base, pf.bound/n){
                                      require(pf.word == base.pow(n))}
// l(e) = 0
case object Empty extends LinNormBound(Word(Vector()), 0)
</code>
</pre>
<div id="//_class_whose_objec">
<script>document.getElementById("//_class_whose_objec").innerHTML = codeNum["// class whose objec"];</script>
</div>
</div>
<p class="paragraph">
<span class="text">Note however the inductive type family </span>
<span class="inlinemath">\(\mathcal{B}\)</span>
<span class="text"> is only partially captured by scala types, with the rest at object level in scala. Specifically, if code does not use homogeneity and typechecks (in scala) with type of the form </span>
<em>
<span class="text">LinNormBound(word, bound)</span>
</em>
<span class="text">, the corresponding object is in fact a valid proof. However, we need to load to check correctness of proofs involving homogeneity (for which we have the </span>
<em>
<span class="text">require</span>
</em>
<span class="text"> statement). Further the scala types do not determine </span>
<span class="inlinemath">\(g\)</span>
<span class="text"> and </span>
<span class="inlinemath">\(a\)</span>
<span class="text"> in </span>
<span class="inlinemath">\(\mathcal{B}(g)(a)\)</span>
<span class="text"> so these can only be determined at runtime.

Crucially, any object that </span>
<em>
<span class="text">loads</span>
</em>
<span class="text"> (including passing the require test) is a valid proof. This is independent of how the object was created, whether this was algorithmic, manual, or a combination of these. It is also straightforward to translate such an object to a human readable form</span>
<span class="notemark">
<a href="#footer">
<sup>[?]</sup>
</a>
</span>
<span class="text">.


</span>
</p>
<div class="heading">
<span class="section">
<span id="sectionNon-crossing_matchings_and_bounds_using_conjugacy_invariance">
<script>document.getElementById("sectionNon-crossing_matchings_and_bounds_using_conjugacy_invariance").innerHTML = headNum["sectionNon-crossing matchings and bounds using conjugacy invariance"];</script>
</span>
<a name="S:noncross">
</a>Non-crossing matchings and bounds using conjugacy invariance</span>
</div>
<p class="paragraph">
<span class="text">We now explain the algorithm used to find proofs of bounds. While this was in a public repository, it was not emphasised during the collaboration and its details played no role in the proof of the main result. We have already emphasised that the computer generated proof, and its correctness, were independent of this algorithm.

By an algorithm to give a proof, we mean an algorithm that takes as input an element </span>
<span class="inlinemath">\(g\in\langle \alpha, \beta \rangle\)</span>
<span class="text"> and has output some bound </span>
<span class="inlinemath">\(B(g)(a)\)</span>
<span class="text">. Formally, this is a </span>
<em>
<span class="text">total</span>
</em>
<span class="text"> function of type </span>
<span class="inlinemath">\(\langle \alpha, \beta \rangle \to \sum_{a\in\mathbb{R}}\mathcal{B}(g)(a)\)</span>
<span class="text">. We define such functions recursively.

First, observe that if we only used the triangle inequality and the bound on generators, then the best bound we get is the </span>
<em>
<span class="text">reduced word length</span>
</em>
<span class="text">. Namely, by definition any </span>
<span class="inlinemath">\(g\in\langle \alpha, \beta \rangle\)</span>
<span class="text"> can be expressed as a product </span>
<span class="inlinemath">\(g=l_1l_2\dots l_k\)</span>
<span class="text"> of generators and their inverses. Further, by performing cancellations if necessary, we can assume that the expression </span>
<span class="inlinemath">\(g=l_1l_2\dots l_k\)</span>
<span class="text"> is reduced, i.e. does not admit further cancellations (being reduced is equivalent to </span>
<span class="inlinemath">\(l_i\neq l_{i+1}^{-1}\ \forall i, 1\leq i &lt;k\)</span>
<span class="text"> ). It is well known that the reduced form is unique.

By induction, using the triangle inequality we obtain the bound </span>
<span class="inlinemath">\(l(g)\leq k\)</span>
<span class="text">. This is in fact sharp if we assume only that </span>
<span class="inlinemath">\(l\)</span>
<span class="text"> is a normalized pseudo-length.

Further, it is straightforward to translate the inductive proof of the bound </span>
<span class="inlinemath">\(l(g)\leq k\)</span>
<span class="text"> into a recursive (on word length) definition of a function </span>
<span class="inlinemath">\(\varphi: \langle \alpha, \beta \rangle \to \sum_{a\in\mathbb{R}}\mathcal{B}(g)(a)\)</span>
<span class="text">. Assume all words are reduced. We make the following definition.
</span>
</p>
<ul>
<li class="item">
<div class="body">
<p class="paragraph">
<span class="text">For the empty word </span>
<span class="inlinemath">\(e\)</span>
<span class="text">, define </span>
<span class="inlinemath">\(\varphi(e) = (0, \mathfrak{e}): \sum_{a\in\mathbb{R}}\mathcal{B}(e)(a)\)</span>
<span class="text">, whose type is correct as </span>
<span class="inlinemath">\(\mathfrak{e} : \mathcal{B}(e)(0)\)</span>
<span class="text">.
  </span>
</p>
</div>
</li>
<li class="item">
<div class="body">
<p class="paragraph">
<span class="text">If </span>
<span class="inlinemath">\(g=sh\)</span>
<span class="text"> and </span>
<span class="inlinemath">\(\varphi(h) = (a, p)\)</span>
<span class="text">, define </span>
<span class="inlinemath">\(\varphi(g) = (a + 1, \mathfrak{t}(s)(h)(1)(a)(\mathfrak{g}(s))(p))\)</span>
<span class="text">, whose type is correct as </span>
<span class="inlinemath">\(\mathfrak{t}(s)(h)(1)(a)(\mathfrak{g}(s))(p) : \mathcal{B}(g)(a + 1)\)</span>
<span class="text">.
</span>
</p>
</div>
</li>
</ul>
<p class="paragraph">
<span class="text">If we now use the hypothesis of conjugacy invariance, we get in general sharper bounds (and their proofs) recursively. Namely, in the case where </span>
<span class="inlinemath">\(g=sh\)</span>
<span class="text">, we get a bound which is the minimum of </span>
<span class="inlinemath">\(1\)</span>
<span class="text"> or more bounds (i.e., we get several bounds of which we choose a minimal one), namely
</span>
</p>
<ul>
<li class="item">
<div class="body">
<p class="paragraph">
<span class="text">If we have a proof </span>
<span class="inlinemath">\(p: \mathcal{B}(a)(h)\)</span>
<span class="text">, i.e., a proof of </span>
<span class="inlinemath">\(l(h)\leq a\)</span>
<span class="text">, by the triangle inequality as above we get a proof of </span>
<span class="inlinemath">\(l(g) \leq a + 1\)</span>
<span class="text">, i.e., a term of type </span>
<span class="inlinemath">\(\mathcal{B}(g)(a + 1)\)</span>
<span class="text">.
  </span>
</p>
</div>
</li>
<li class="item">
<div class="body">
<p class="paragraph">
<span class="text">For each expression of </span>
<span class="inlinemath">\(h\)</span>
<span class="text"> as </span>
<span class="inlinemath">\(h_1s^{-1}h_2\)</span>
<span class="text"> we see that </span>
<span class="inlinemath">\(l(g) = l(sh_1s^{-1}h_2) \leq l(sh_1s^{-1}) + l(h_2) = l(h_1) + l(h_2)\)</span>
<span class="text"> using conjugacy invariant. Given proofs of bounds  </span>
<span class="inlinemath">\(l(h_1)\leq a_1\)</span>
<span class="text"> and </span>
<span class="inlinemath">\(l(h_2)\leq a_2\)</span>
<span class="text">, we get a proof of the bound </span>
<span class="inlinemath">\(l(g)\leq a_1 + a_2\)</span>
<span class="text">, i.e., from terms of type </span>
<span class="inlinemath">\(\mathcal{B}(h_1)(a_1)\)</span>
<span class="text"> and </span>
<span class="inlinemath">\(\mathcal{B}(h_2)(a_2)\)</span>
<span class="text"> we obtain a term of type </span>
<span class="inlinemath">\(\mathcal{B}(g)(a_1+ a_2)\)</span>
<span class="text">.
</span>
</p>
</div>
</li>
</ul>
<p class="paragraph">
<span class="text">Interestingly, this is also optimal if we only assume that </span>
<span class="inlinemath">\(l\)</span>
<span class="text"> is a normalized, conjugacy-invariant pseudo-length (see, for instance, </span>
<span class="citation">
<sup>
<strong>gadgil</strong>
</sup>
</span>
<span class="text">).

Note that the above recursive definition can be modified to use any finite collection of proofs of bounds previously obtained. Indeed, this is important for efficiency, even where we do not use homogeneity, so that we avoid repeating computations (this is called memoization).

In particular, we can choose to use homogeneity for specified elements and powers. This is what was done in generating the proofs, with the elements chosen based on experience obtained from the breakdown of attmepted  constructions (specifically one following</span>
<span class="citation">
<sup>
<strong>gadgil</strong>
</sup>
</span>
<span class="text">).</span>
<span class="notemark">
<a href="#footer">
<sup>[?]</sup>
</a>
</span>
<span class="text">

</span>
</p>
<div class="heading">
<span class="section">
<span id="sectionConcluding_remarks">
<script>document.getElementById("sectionConcluding_remarks").innerHTML = headNum["sectionConcluding remarks"];</script>
</span>
<a name="S:Conclusions">
</a>Concluding remarks</span>
</div>
<p class="paragraph">
<span class="text">There were two limitations in our computer searches. The first (and minor one) was the manual choice of elements and powers for which homogeneity was applied. It would have been straightforward to have replaced this by some learning methods, and this only did not happen due to the sheer speed of the discovery of the proof of Theorem</span>
<span class="reference">
<a id="refmain" href="#main">
<script>document.getElementById("refmain").innerHTML = labelNum["main"];</script>
</a>
</span>
<span class="text">.

The more serious shortcoming was that only explicit bounds for explicit elements could be represented by objects. Hence neither statements involving quantification nor proofs by induction were implemented. Note that this was only a limitation of the scala code, not the underlying type theory.

Indeed, the type theoretic formulation had no restrictions on quantification, and natural embedded in fully general foundations of mathematics, based on Homotopy Type Theory. Further, the formualtion is a reasonably concise and natural representation of real-world mathematics.



To illustrate that this is not an inherent limitation of the state of the art, we embdedded our domain specific foundations in our implementation of homotopy type theory with symbolic algebra, which is part of the ProvingGround project. Further, we formalized the proof of the internal repetition trick.</span>
<span class="notemark">
<a href="#footer">
<sup>[?]</sup>
</a>
</span>
<span class="text">.

Most mathematics in the real world is rigorous only in a local sense, following established conventions of a field. We feel that the natural way to work with this is to make domain specific foundations codifying these, and then embed these in Homotopy Type Theory, using the modular nature of HoTT so that the embedding is both concise and transparent. We hope that this work has been an example of how this can work.

</span>
</p>
<div class="bibliography">
<h2 class="bibtitle">References</h2>
<ol>
<li>
<div class="body">
<p class="paragraph">
<span class="text">S.Gadgil, </span>
<em>
<span class="text"> Watson--Crick pairing, the Heisenberg group and Milnor
  invariants</span>
</em>
<span class="text">, Journal
  of Mathematical Biology 59(1), 2009.

</span>
</p>
</div>
</li>
<li>
<div class="body">
<p class="paragraph">
<span class="text">D.H.J. PolyMath, </span>
<em>
<span class="text">Homogeneous length functions on Groups</span>
</em>
<span class="text">, to appear in Algebra and Number Theory.

</span>
</p>
</div>
</li>
<li>
<div class="body">
<p class="paragraph">
<span class="text">Vladimir Voevodsky et al. </span>
<em>
<span class="text">Homotopy type theory: Univalent foundations
of mathematics</span>
</em>
<span class="text">. Institute for Advanced Study (Princeton), The Univalent
Foundations Program, 2013.

</span>
</p>
</div>
</li>
</ol>
</div>
</div>
</div>
<div id="footer">
<ol>
<li>
<p class="paragraph">
<strong>
<span class="text">Participants:</span>
</strong>
<span class="text"> T. Fritz, S. Gadgil, A. Khare, P. Nielsen, L. Silberman, T. Tao.</span>
</p>
</li>
<li>
<p class="paragraph">
<span class="text">see </span>
<span class="hyperlink">
<a href="https://github.com/siddhartha-gadgil/Superficial/wiki/A-commutator-bound">https://github.com/siddhartha-gadgil/Superficial/wiki/A-commutator-bound</a>
</span>
<span class="text"> for the full proof as originally posted.</span>
</p>
</li>
<li>
<p class="paragraph">
<span class="text">the posted translation was inductive on the cases and used </span>
<em>
<span class="text">unicode</span>
</em>
<span class="text"> to handle the mathematics</span>
</p>
</li>
<li>
<p class="paragraph">
<span class="text">The elements chosen were of the form </span>
<span class="inlinemath">\(\alpha[\alpha, \beta]^k\)</span>
<span class="text"> and a range of powers was taken with the best bound retained. After seeing the final proof it is clear we should have considered the more general form </span>
<span class="inlinemath">\(\alpha^l[\alpha, \beta]^k\)</span>
<span class="text">.</span>
</p>
</li>
<li>
<p class="paragraph">
<span class="text">see </span>
<span class="hyperlink">
<a href="http://siddhartha-gadgil.github.io/ProvingGround/tuts/internal-repetition-for-length-functions.html">http://siddhartha-gadgil.github.io/ProvingGround/tuts/internal-repetition-for-length-functions.html</a>
</span>
</p>
</li>
</ol>
</div>
</body>
</html>